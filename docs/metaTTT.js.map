{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/control.js","webpack:///./src/app/main.js","webpack:///./src/app/metaGrid.js","webpack:///./src/styles/grid.css","webpack:///./src/styles/main.css"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;ACnEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,sBAAsB;AACnD,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,sBAAsB;AACnD,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;;;;;;ACjKmB;AACD;;AAElB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;;;;AC3BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACrKA,yC;;;;;;;;;;;ACAA,yC","file":"metaTTT.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/app/main.js\");\n","/**\n * Handles game-play logic and player control.\n */\nexport class Control {\n    /**\n     * Construct a control object and attach it to the root grid.\n     * @param {MetaGrid} rootGrid The root of a MetaGrid.\n     */\n    constructor(rootGrid) {\n        let _previousPlayer = 0;\n\n        const currentPlayer = () => {\n            return _previousPlayer ^= 1;\n        };\n\n        const applyToLeafs = (grid, method) => {\n            if (grid.isLeaf()) {\n                method(grid);\n                return;\n            }\n\n            for (let row = 0; row < grid.getSize(); row++) {\n                for (let col = 0; col < grid.getSize(); col++) {\n                    applyToLeafs(grid.getChild(row, col), method);\n                }\n            }\n        };\n\n        const checkRows = grid => {\n            for (let row = 0; row < grid.getSize(); row++) {\n                const firstCell = grid.getChild(row, 0).getMark();\n                if (firstCell == null)\n                    continue;\n\n                let col;\n                for (col = 0; col < grid.getSize(); col++) {\n                    if (grid.getChild(row, col).getMark() !== firstCell)\n                        break;\n                }\n\n                if (col === grid.getSize())\n                    return true;\n            }\n\n            return false;\n        };\n\n        const checkColumns = grid => {\n            for (let col = 0; col < grid.getSize(); col++) {\n                const firstCell = grid.getChild(0, col).getMark();\n                if (firstCell == null)\n                    continue;\n\n                let row;\n                for (row = 0; row < grid.getSize(); row++) {\n                    if (grid.getChild(row, col).getMark() !== firstCell)\n                        break;\n                }\n\n                if (row === grid.getSize())\n                    return true;\n            }\n\n            return false;\n        };\n\n        const checkDiagonals = grid => {\n            const firstLeftCell = grid.getChild(0, 0).getMark();\n            const firstRightCell = grid.getChild(0, grid.getSize()-1).getMark();\n\n            let leftDiagonal = true, rightDiagonal = true;\n            for (let index = 0; index < grid.getSize(); index++) {\n                if (grid.getChild(index, index).getMark() !== firstLeftCell) {\n                    leftDiagonal = false;\n                }\n\n                let mirrorIndex = grid.getSize() - index - 1;\n                if (grid.getChild(index, mirrorIndex).getMark() !== firstRightCell) {\n                    rightDiagonal = false;\n                }\n            }\n            return firstLeftCell  != null && leftDiagonal ||\n                firstRightCell != null && rightDiagonal;\n        };\n\n        const checkWin = (grid, checkMark) => {\n            if (grid.isMarked())\n                return;\n\n            if (checkRows(grid) || checkColumns(grid) || checkDiagonals(grid)) {\n                grid.setMark(checkMark);\n\n                if (!grid.isRoot())\n                    checkWin(grid.getParent(), checkMark);\n            }\n        };\n\n        const countMarked = grid => {\n            let numMarked = 0;\n            for (let row = 0; row < grid.getSize(); row++)\n                for (let col = 0; col < grid.getSize(); col++)\n                    if (grid.getChild(row, col).isMarked())\n                        numMarked++;\n            return numMarked;\n        };\n\n        const isFilled = grid => {\n            const numChildren = grid.getSize() * grid.getSize();\n            return countMarked(grid) === numChildren;\n        };\n\n        const findEmpty = grid => {\n            for (let row = 0; row < grid.getSize(); row++) {\n                for (let col = 0; col < grid.getSize(); col++) {\n                    const child = grid.getChild(row, col);\n                    if (!isFilled(child)) {\n                        return child;\n                    }\n                }\n            }\n        };\n\n        const enableReverse = (grid, metaIndex) => {\n            if (metaIndex.length === 1) {\n                if (isFilled(grid) && !grid.isRoot())\n                    grid = findEmpty(grid.getParent());\n\n                if (grid == null)\n                    return;\n\n                applyToLeafs(grid, (leaf) => {\n                    leaf.enable(true);\n                });\n\n                return;\n            }\n\n            const childIndex = metaIndex.pop();\n            let child = grid.getChild(childIndex.row, childIndex.col);\n            enableReverse(child, metaIndex);\n        };\n\n        const handleClick = gridLeaf => {\n            const player = currentPlayer();\n            if (gridLeaf.isEnabled() && !gridLeaf.isMarked()) {\n                gridLeaf.setMark(player);\n                checkWin(gridLeaf.getParent(), player);\n\n                applyToLeafs(rootGrid, (leaf) => {\n                    leaf.enable(false);\n                });\n\n                enableReverse(rootGrid, gridLeaf.getMetaIndex());\n            }\n        };\n\n        applyToLeafs(rootGrid, (leaf) => {\n            leaf.getElement().onclick = () => {handleClick(leaf)};\n            leaf.enable(true);\n        });\n    }\n}","import { MetaGrid } from './metaGrid';\nimport { Control } from './control';\n\nimport '../styles/main.css';\n\nconst ID_CONTAINER = 'grid-container',\n      ID_META_SLIDER = 'meta-level',\n      ID_META_DISPLAY = 'level-value',\n      ID_NEW_GAME_BUTTON = 'new-game',\n      GRID_SIZE = 3;\n\nconst metaSlider = document.getElementById(ID_META_SLIDER);\nconst metaDisplay = document.getElementById(ID_META_DISPLAY);\n\nconst setMetaDisplay = () => {\n    metaDisplay.innerText = String(metaSlider.value - 1)\n};\n\nsetMetaDisplay();\nmetaSlider.oninput = setMetaDisplay;\n\ndocument.getElementById(ID_NEW_GAME_BUTTON).onclick = () => {\n    const gridContainer = document.getElementById(ID_CONTAINER);\n    gridContainer.innerHTML = '';\n    const metaGrid = new MetaGrid(GRID_SIZE, metaSlider.value);\n    gridContainer.appendChild(metaGrid.getElement());\n    new Control(metaGrid);\n};","import '../styles/grid.css';\n\n/**\n * Defines a grid that can contain other grids.\n */\nexport class MetaGrid {\n    /**\n     * Construct a meta grid.\n     * @param {Number} size The size of the square grid.\n     * @param {Number} depth The number of nested grids inside this grid.\n     * @param {MetaGrid | undefined} parent The parent of this grid, undefined means this is the root.\n     */\n    constructor(size, depth, parent) {\n        const ATTR_MARK = 'mark',\n              ELEM_GRID = 'div',\n              CLASS_ENABLED = 'enabled';\n\n        const _cells = [];\n        const _element = document.createElement(ELEM_GRID);\n        let _mark;\n        let _enabled = false;\n\n        const updateElement = () => {\n            if (this.isMarked())\n                _element.setAttribute(ATTR_MARK, _mark);\n            if (this.isEnabled())\n                _element.classList.add(CLASS_ENABLED);\n            else\n                _element.classList.remove(CLASS_ENABLED);\n        };\n\n        const makeChildren = () => {\n            _cells.length = 0;\n            _element.innerHTML = '';\n            for (let row = 0; row < size; row++) {\n                _cells[row] = [];\n                for (let col = 0; col < size; col++) {\n                    const cell = new MetaGrid(size, depth - 1, this);\n                    _cells[row].push(cell);\n                    _element.appendChild(cell.getElement());\n                }\n            }\n        };\n\n        const getChildIndex = childGrid => {\n            let childRow = -1;\n            let childCol = -1;\n            for (let row = 0; row < size; row++) {\n                childCol = _cells[row].indexOf(childGrid);\n                if (childCol >= 0) {\n                    childRow = row;\n                    break;\n                }\n            }\n\n            return {row: childRow, col: childCol};\n        };\n\n        /**\n         * Return the index of the grid in its nested state.\n         * @param {MetaGrid} childGrid\n         * @return {Object[]} List of objects containing (row, col) indices.\n         */\n        this.getMetaIndex = childGrid => {\n            if (this.isLeaf())\n                return parent.getMetaIndex(this);\n\n            const childIndex = getChildIndex(childGrid);\n\n            if (this.isRoot())\n                return [childIndex];\n\n            return parent.getMetaIndex(this).concat(childIndex);\n        };\n\n        /**\n         * Return the nested child at (row, col).\n         * @param {Number} row The row that contains the child.\n         * @param {Number} col The column that contains the child.\n         * @return {MetaGrid | undefined} Meta grid if it exists, otherwise undefined.\n         */\n        this.getChild = (row, col) => {\n            if (!this.isLeaf())\n                return _cells[row][col];\n        };\n\n        /**\n         * Return the HTMLElement visualizing the meta grid.\n         * @return {HTMLDivElement}\n         */\n        this.getElement = () => _element;\n\n        /**\n         * Return the size of this meta grid.\n         * @return {Number}\n         */\n        this.getSize = () => size;\n\n        /**\n         * Return the parent of this meta grid.\n         * @return {MetaGrid}\n         */\n        this.getParent = () => parent;\n\n        /**\n         * Return true if this meta grid contains no children.\n         * @return {boolean}\n         */\n        this.isLeaf = () => {\n            return depth === 0;\n        };\n\n        /**\n         * Return true if this meta grid contains no parent.\n         * @return {boolean}\n         */\n        this.isRoot = () => {\n            return parent == null;\n        };\n\n        /**\n         * Assign a mark to this meta grid.\n         * @param {Number} mark Mark to assign.\n         */\n        this.setMark = mark => {\n            _mark = mark;\n            updateElement();\n        };\n\n        /**\n         * Return the mark assigned to this meta grid.\n         * @return {Number} The mark of this grid.\n         */\n        this.getMark = () => {\n            return _mark;\n        };\n\n        /**\n         * Return true if this meta grid contains a mark.\n         * @return {boolean} True if this meta grid is marked.\n         */\n        this.isMarked = () => {\n            return _mark != null;\n        };\n\n        /**\n         * Enable or disable this meta grid for interaction.\n         * @param {boolean} enabled True if this meta grid can be interacted with.\n         */\n        this.enable = enabled => {\n            _enabled = enabled;\n            updateElement();\n        };\n\n        /**\n         * Return true if this meta grid can be interacted with.\n         * @return {boolean} True if this meta grid can be interacted with.\n         */\n        this.isEnabled = () => _enabled;\n\n        if (!this.isLeaf())\n            makeChildren();\n\n        updateElement();\n    }\n}\n","// removed by extract-text-webpack-plugin","// removed by extract-text-webpack-plugin"],"sourceRoot":""}